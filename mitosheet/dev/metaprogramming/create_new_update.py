


from typing import Dict

from metaprogramming.create_new_step import get_ts_function_params
from metaprogramming.utils.code_utils import CLOSE_BRACKET, OPEN_BRACKET
from metaprogramming.utils.path_utils import (get_updates_folder, get_src_folder,
                                              write_python_code_file)
from metaprogramming.utils.user_input_utils import read_params

UPDATE_IMPORT_MARKER = '# AUTOGENERATED LINE: UPDATE IMPORT (DO NOT DELETE)'
UPDATE_EXPORT_MARKER = '# AUTOGENERATED LINE: UPDATE EXPORT (DO NOT DELETE)'
API_TSX_UPDATE_MARKER = '// AUTOGENERATED LINE: API UPDATE (DO NOT DELETE)'


def get_update_call_python_code_params(params: Dict[str, str]) -> str:
    return ', '.join(f'{name}: {type},' for name, type in params.items())

def get_update_python_code(name: str, params: Dict[str, str]) -> str:
    capital_name = name.upper().replace(' ', '_')

    return f"""#!/usr/bin/env python
# coding: utf-8

# Copyright (c) Saga Inc.
# Distributed under the terms of the GPL License.
from typing import List

from mitosheet.types import StepsManagerType

{capital_name}_EVENT = '{name.replace(' ', '_')}'
{capital_name}_PARAMS: List[str] = {list(params.keys())}

def execute_{name}_update(steps_manager: StepsManagerType, {get_update_call_python_code_params(params)}) -> None:
    pass
    # TODO: impement the function

{capital_name}_UPDATE = {OPEN_BRACKET}
    'event_type': {capital_name}_EVENT,
    'params': {capital_name}_PARAMS,
    'execute': execute_{name}_update
{CLOSE_BRACKET}
"""

def write_to_update_py_file(name: str) -> None:
    capital_name = name.capitalize()
    path_to_update_py = get_updates_folder() / '__init__.py'

    with open(path_to_update_py, 'r') as f:
        code = f.read()
        code = code.replace(UPDATE_IMPORT_MARKER, f"from mitosheet.updates.{name} import {capital_name}_UPDATE\n{UPDATE_IMPORT_MARKER}")
        code = code.replace(UPDATE_EXPORT_MARKER, f"{capital_name}_UPDATE,\n    {UPDATE_EXPORT_MARKER}""")

    with open(path_to_update_py, 'w') as f:
        f.write(code)

def get_typescript_update_code(name: str, params: Dict[str, str]) -> str:
    ts_function_name = "update" + "".join([s.title() for (idx, s) in enumerate(name.split(' ')) if idx != 0])
    params_type = F"{OPEN_BRACKET}{get_ts_function_params(params)}{CLOSE_BRACKET}"

    return f"""
    async {ts_function_name}(params: {params_type}): Promise<void> {OPEN_BRACKET}

        await this.send<string>({OPEN_BRACKET}
            'event': 'update_event',
            'type': '{name.replace(' ', '_')}',
            'params': params
        {CLOSE_BRACKET}, {OPEN_BRACKET}{CLOSE_BRACKET})
    {CLOSE_BRACKET}"""

def write_to_typscript_api(name: str, params: Dict[str, str]) -> None:
    path_to_api_tsx = get_src_folder() / 'jupyter' / 'api.tsx'

    with open(path_to_api_tsx, 'r') as f:
        code = f.read()
        code = code.replace(API_TSX_UPDATE_MARKER, get_typescript_update_code(name, params) + f'\n\n    {API_TSX_UPDATE_MARKER}')

    with open(path_to_api_tsx, 'w') as f:
        f.write(code)


def create_new_update_call(name: str) -> None:
    params = read_params()

    api_call_path = get_updates_folder() / f"{name}.py"
    api_code = get_update_python_code(name, params)

    # Create the file
    write_python_code_file(api_call_path, api_code)

    write_to_update_py_file(name)

    # Write the typescript to the API
    write_to_typscript_api(name, params)