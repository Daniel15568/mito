{"version":3,"file":"extension.js","mappings":";;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,aAAa,GAAG;AACrE;AACA;AACA,kDAAkD,cAAc;AAChE;AACA,kDAAkD,wBAAwB,gCAAgC,wBAAwB,UAAU,EAAE,qBAAqB;AACnK;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,2BAA2B;AAC9D;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,MAAM,MAAM,MAAM;AACnD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,qDAAqD,iEAAiE;AACtH;AACA;AACA,KAAK;AACL;AACA;AACA,yDAAyD;AACzD,yDAAyD;AACzD,yDAAyD;AACzD;AACA;AACA;AACA,4EAA4E,aAAa;AACzF;AACO;AACP;AACA;AACA,iGAAiG,aAAa;AAC9G;AACA;AACA,4EAA4E,aAAa;AACzF;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtIA;AACA;AAC2D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wEAAuB;AACnC,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtCuP;AAChP;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,aAAa;AAClF;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wFAAiD;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,0DAAmB,gCAAgC,mFAA4C;AACvH;AACA;AACA;AACA;AACA,sBAAsB,0DAAmB,8BAA8B,mFAA4C;AACnH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,0DAAmB,wBAAwB,mFAA4C;AAC3G;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,QAAQ,0DAAmB,uBAAuB,wFAAiD;AACnG;AACA,kFAAkF,gBAAgB,4BAA4B,gBAAgB;AAC9I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,QAAQ,0DAAmB,kBAAkB,mFAA4C;AACzF,mCAAmC,mEAA4B;AAC/D;AACA;AACA;AACA;AACA;AACA,iDAAiD,aAAa;AAC9D;AACA;AACA,mDAAmD,aAAa;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,mEAA4B;AAC3C;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,iBAAiB,oDAAa;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6EAA6E,kEAA2B;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,kEAA2B;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,4CAA4C;AAC5E;AACA;AACA;AACA;AACA,gCAAgC,4CAA4C;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;UCrQA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCzBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,EAAE;WACF;WACA;;;;;WCVA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;UENA;UACA;UACA;UACA","sources":["webpack://mitosheet/./lib/jupyter/code.js","webpack://mitosheet/./lib/jupyter/notebook/extension.js","webpack://mitosheet/./lib/jupyter/notebook/extensionUtils.js","webpack://mitosheet/webpack/bootstrap","webpack://mitosheet/webpack/runtime/define property getters","webpack://mitosheet/webpack/runtime/harmony module decorator","webpack://mitosheet/webpack/runtime/hasOwnProperty shorthand","webpack://mitosheet/webpack/runtime/make namespace object","webpack://mitosheet/webpack/before-startup","webpack://mitosheet/webpack/startup","webpack://mitosheet/webpack/after-startup"],"sourcesContent":["// Utilities for working with the generated code\nconst IMPORT_STATEMENTS = [\n    'from mitosheet.public.v1 import *',\n    'from mitosheet.public.v2 import *',\n    'from mitosheet.public.v3 import *',\n];\nexport function getCodeString(analysisName, code, telemetryEnabled, publicInterfaceVersion) {\n    if (code.length == 0) {\n        return '';\n    }\n    const finalCode = code.join('\\n');\n    // If telemetry not enabled, we want to be clear about this by\n    // simply not calling a func w/ the analysis name\n    let analysisRegisterCode = '';\n    if (telemetryEnabled) {\n        analysisRegisterCode = `register_analysis(\"${analysisName}\");`;\n    }\n    else {\n        analysisRegisterCode = `# Analysis Name:${analysisName};`;\n    }\n    return finalCode.replace(`mitosheet.public.v${publicInterfaceVersion} import *`, `mitosheet.public.v${publicInterfaceVersion} import *; ${analysisRegisterCode}`);\n}\n// Returns the last line with any non-whitespace character\nexport function getLastNonEmptyLine(codeText) {\n    const filteredActiveText = codeText.split(/\\r?\\n/).filter(line => line.trim().length > 0);\n    return filteredActiveText.length > 0 ? filteredActiveText.pop() : undefined;\n}\nexport const getArgsFromMitosheetCallCode = (codeText) => {\n    const codeTextCleaned = removeWhitespaceInPythonCode(codeText);\n    let nameString = codeTextCleaned.split('sheet(')[1].split(')')[0];\n    // If there is a (new) analysis name parameter passed, we ignore it\n    if (nameString.includes('analysis_to_replay')) {\n        nameString = nameString.split('analysis_to_replay')[0].trim();\n    }\n    // If there is a view_df name parameter, we ignore it\n    // TODO: remove this on Jan 1, 2023 (since we no longer need it)\n    if (nameString.includes('view_df')) {\n        nameString = nameString.split('view_df')[0].trim();\n    }\n    if (nameString.includes('sheet_functions')) {\n        nameString = nameString.split('sheet_functions')[0].trim();\n    }\n    // Get the args and trim them up\n    let args = nameString.split(',').map(dfName => dfName.trim());\n    // Remove any names that are empty. Note that some of these names\n    // may be strings, which we turn into valid df_names on the backend!\n    args = args.filter(dfName => { return dfName.length > 0; });\n    return args;\n};\n// Returns true iff a the given cell ends with a mitosheet.sheet call\nexport function isMitosheetCallCode(codeText) {\n    // Get the last non-empty line from the cell\n    const lastLine = getLastNonEmptyLine(codeText);\n    if (lastLine === undefined) {\n        return false;\n    }\n    /*\n        We check if the last line contains a mitosheet.sheet call, which can happen in a few ways\n        \n        1. `import mitosheet` -> mitosheet.sheet()\n        2. `import mitosheet as {THING}` -> {THING}.sheet(\n        3. `from mitosheet import sheet` -> sheet(\n\n        We detect all three by checking if the line contains `sheet(`!\n    */\n    const lastLineCleaned = removeWhitespaceInPythonCode(lastLine);\n    return lastLineCleaned.indexOf('sheet(') !== -1;\n}\n// Returns true iff a the given cell is a cell containing the generated code\nexport function isMitoAnalysisCode(codeText) {\n    // Check if it starts with any import statement from the versioned interface\n    let startsWithPublicVersionImport = false;\n    IMPORT_STATEMENTS.forEach(importStatement => {\n        if (codeText.startsWith(importStatement + '; register_analysis(') || codeText.startsWith(importStatement + '; # Analysis Name:')) {\n            startsWithPublicVersionImport = true;\n        }\n    });\n    // Handle the old and new Mito boilerplate code\n    return codeText.startsWith('# MITO CODE START')\n        || codeText.startsWith('from mitosheet import *; register_analysis(')\n        || codeText.startsWith('from mitosheet import *; # Analysis:')\n        || codeText.startsWith('from mitosheet import *; # Analysis Name:')\n        || startsWithPublicVersionImport;\n}\n/*\n    Returns true if the cell contains a mitosheet.sheet(analysis_to_replay={analysisName})\n*/\nexport function containsMitosheetCallWithSpecificAnalysisToReplay(codeText, analysisName) {\n    // Remove any whitespace from codeText\n    const codeTextCleaned = removeWhitespaceInPythonCode(codeText);\n    return codeTextCleaned.includes('sheet(') && codeTextCleaned.includes(`analysis_to_replay=\"${analysisName}\"`);\n}\n/*\n    Returns true if the cell contains a mitosheet.sheet(analysis_to_replay={analysisName})\n*/\nexport function containsMitosheetCallWithAnyAnalysisToReplay(codeText) {\n    // Remove any whitespace from codeText\n    const codeTextCleaned = removeWhitespaceInPythonCode(codeText);\n    return isMitosheetCallCode(codeText) && codeTextCleaned.includes(`analysis_to_replay=`);\n}\n/**\n * This function is used to identify if the user has changed the contents of the code\n * cell that Mito is using to store the generated code. We need to know this to avoid\n * overwriting the user's code with the generated code.\n * @param oldCode - The last analysisData code that was written to the cell\n * @param codeCellText - The text in the cell that contains the code\n * @returns boolean indicating if the code cell has been changed\n */\nexport function hasCodeCellBeenEditedByUser(oldCode, codeCellText) {\n    // We're removing the first line of the old code and the cell code because\n    // the cell code contains the analysis id and the old code does not\n    const oldCodeWithoutFirstLine = oldCode === null || oldCode === void 0 ? void 0 : oldCode.slice(1).join('\\n');\n    const cellCodeWithoutFirstLine = codeCellText === null || codeCellText === void 0 ? void 0 : codeCellText.split('\\n').slice(1).join('\\n');\n    return oldCodeWithoutFirstLine !== cellCodeWithoutFirstLine;\n}\n// Removes all whitespace from a string, except for whitespace in quoted strings.\nexport function removeWhitespaceInPythonCode(codeText) {\n    const pattern = /('[^']*'|\"[^\"]*\")/;\n    // This pattern matches:\n    // 1. A single-quoted string containing any character except for '.\n    // 2. OR a double-quoted string containing any character except for \".\n    // Split the text into quoted strings and non-quoted sections.\n    const parts = codeText.split(pattern);\n    // Remove all whitespace from non-quoted sections.\n    const partsWithoutSpaces = parts.map((part) => {\n        if (pattern.test(part)) {\n            return part; // Keep quoted strings unchanged.\n        }\n        return part.replace(/\\s+/g, '');\n    });\n    // Join the parts back into a single string.\n    const result = partsWithoutSpaces.join('');\n    return result;\n}\n//# sourceMappingURL=code.js.map","// Copyright (c) Jupyter Development Team.\nvar _a, _b;\nimport { writeEmptyMitosheetCell } from \"./extensionUtils\";\n// This file contains the javascript that is run when the notebook is loaded.\n// It contains some requirejs configuration and the `load_ipython_extension`\n// which is required for any notebook extension.\n//\n// Some static assets may be required by the custom widget javascript. The base\n// url for the notebook is not known at build time and is therefore computed\n// dynamically.\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nwindow.__webpack_public_path__ = ((_a = document.querySelector('body')) === null || _a === void 0 ? void 0 : _a.getAttribute('data-base-url')) + 'nbextensions/mitosheet';\n// Configure requirejs\nif (window.require) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    window.require.config({\n        map: {\n            \"*\": {\n                \"mitosheet\": \"nbextensions/mitosheet/index\",\n            }\n        }\n    });\n}\n// Try to add a button\n(_b = window.Jupyter) === null || _b === void 0 ? void 0 : _b.toolbar.add_buttons_group([{\n        id: 'mito-toolbar-button-id',\n        label: 'New Mitosheet',\n        title: 'Create a blank Mitosheet below the active code cell',\n        icon: 'fa-regular fa-table',\n        callback: () => {\n            writeEmptyMitosheetCell();\n        },\n    }]);\n// Export the required load_ipython_extension\nmodule.exports = {\n    // eslint-disable-next-line  @typescript-eslint/no-empty-function\n    load_ipython_extension: function () { }\n};\n//# sourceMappingURL=extension.js.map","import { containsMitosheetCallWithAnyAnalysisToReplay, containsMitosheetCallWithSpecificAnalysisToReplay, getArgsFromMitosheetCallCode, getCodeString, hasCodeCellBeenEditedByUser, isMitosheetCallCode, removeWhitespaceInPythonCode } from \"../code\";\nexport function getCellAtIndex(index) {\n    var _a, _b;\n    return (_b = (_a = window.Jupyter) === null || _a === void 0 ? void 0 : _a.notebook) === null || _b === void 0 ? void 0 : _b.get_cell(index);\n}\nexport function getCellText(cell) {\n    return (cell === null || cell === void 0 ? void 0 : cell.get_text()) || '';\n}\n/*\n    Returns True if the passed cell is empty.\n    Returns False if the passed cells is either not empty or undefined\n*/\nexport function isEmptyCell(cell) {\n    if (cell === undefined) {\n        return false;\n    }\n    const currentCode = getCellText(cell);\n    return currentCode.trim() === '';\n}\n/**\n * Returns the cell that has the mitosheet.sheet(analysis_to_replay={analysisName}) in it,\n * or undefined if no such cell exists\n */\nexport function getCellCallingMitoshetWithAnalysis(analysisName) {\n    var _a, _b;\n    const cells = (_b = (_a = window.Jupyter) === null || _a === void 0 ? void 0 : _a.notebook) === null || _b === void 0 ? void 0 : _b.get_cells();\n    if (cells === undefined) {\n        return undefined;\n    }\n    let cellIndex = 0;\n    for (const cell of cells) {\n        if (containsMitosheetCallWithSpecificAnalysisToReplay(getCellText(cell), analysisName)) {\n            return [cell, cellIndex];\n        }\n        cellIndex++;\n    }\n    return undefined;\n}\n/**\n * A function that returns the [cell, index] pair of the mitosheet.sheet() call that contains\n * the analysis name.\n *\n * If no mitosheet.sheet() call contains this analysis name, then we assume it hasen't been\n * written yet, and take our best guess at which sheet this is.\n *\n * Returns undefined if it can find no good guess for a calling mitosheet cell.\n */\nexport function getMostLikelyMitosheetCallingCell(analysisName) {\n    var _a, _b, _c, _d, _e, _f, _g, _h;\n    // First, we check if this analysis name is in a mitosheet call, in which case things are easy\n    if (analysisName) {\n        const mitosheetCallCellAndIndex = getCellCallingMitoshetWithAnalysis(analysisName);\n        if (mitosheetCallCellAndIndex !== undefined) {\n            return mitosheetCallCellAndIndex;\n        }\n    }\n    const cells = (_b = (_a = window.Jupyter) === null || _a === void 0 ? void 0 : _a.notebook) === null || _b === void 0 ? void 0 : _b.get_cells();\n    if (cells == undefined) {\n        return;\n    }\n    const activeCell = (_d = (_c = window.Jupyter) === null || _c === void 0 ? void 0 : _c.notebook) === null || _d === void 0 ? void 0 : _d.get_cell((_f = (_e = window.Jupyter) === null || _e === void 0 ? void 0 : _e.notebook) === null || _f === void 0 ? void 0 : _f.get_anchor_index());\n    const activeCellIndex = ((_h = (_g = window.Jupyter) === null || _g === void 0 ? void 0 : _g.notebook) === null || _h === void 0 ? void 0 : _h.get_anchor_index()) || 0;\n    const previousCell = getCellAtIndex(activeCellIndex - 1);\n    // As the most common way for a user to run a cell for the first time is to run and advanced, this \n    // means that the active cell will most likely be one below the mitosheet.sheet() call we want to \n    // write to, so we check this first\n    if (previousCell && isMitosheetCallCode(getCellText(previousCell)) && !containsMitosheetCallWithAnyAnalysisToReplay(getCellText(previousCell))) {\n        return [previousCell, activeCellIndex - 1];\n    }\n    // The next case we check is if they did a run and not advance, which means that the currently\n    // selected cell is the mitosheet.sheet call\n    if (activeCell && isMitosheetCallCode(getCellText(activeCell)) && !containsMitosheetCallWithAnyAnalysisToReplay(getCellText(activeCell))) {\n        return [activeCell, activeCellIndex];\n    }\n    // The last case is that the user did some sort of run all, in which case we cross our fingers\n    // that there is only one cell that does not have a mitosheet call with an analysis_to_replay, \n    // and go looking for it\n    let index = activeCellIndex;\n    while (index >= 0) {\n        const cell = getCellAtIndex(index);\n        if (cell && isMitosheetCallCode(getCellText(cell)) && !containsMitosheetCallWithAnyAnalysisToReplay(getCellText(cell))) {\n            return [cell, index];\n        }\n        index--;\n    }\n    return undefined;\n}\nexport function writeToCell(cell, code) {\n    if (cell == undefined) {\n        return;\n    }\n    cell.set_text(code);\n}\n/**\n * Given a cell, will check if it has a mitosheet.sheet() call with the old\n * analysis to replay, and if so will replace it with the new analysis to\n * replay\n */\nexport function tryOverwriteAnalysisToReplayParameter(cell, oldAnalysisName, newAnalysisName) {\n    if (isMitosheetCallCode(getCellText(cell)) && containsMitosheetCallWithSpecificAnalysisToReplay(getCellText(cell), oldAnalysisName)) {\n        const currentCode = getCellText(cell);\n        const newCode = currentCode.replace(RegExp(`analysis_to_replay\\\\s*=\\\\s*\"${oldAnalysisName}\"`), `analysis_to_replay=\"${newAnalysisName}\"`);\n        writeToCell(cell, newCode);\n        return true;\n    }\n    return false;\n}\n/**\n * Given a cell, will check if it has a mitosheet.sheet() call with no\n * analysis_to_replay, and if so add the analysisName as a parameter to\n * this cell. It will return true in this case.\n *\n * Otherwise, if this is not a mitosheet.sheet() call, or if it already has\n * a analysis_to_replay parameter, this will return false.\n */\nexport function tryWriteAnalysisToReplayParameter(cell, analysisName) {\n    const currentCode = getCellText(cell);\n    if (isMitosheetCallCode(currentCode) && !containsMitosheetCallWithAnyAnalysisToReplay(currentCode)) {\n        const currentCodeCleaned = removeWhitespaceInPythonCode(currentCode);\n        // We know the mitosheet.sheet() call is the last thing in the cell, so we \n        // just replace the last closing paren\n        const lastIndex = currentCode.lastIndexOf(')');\n        let replacement = ``;\n        if (currentCodeCleaned.includes('sheet()')) {\n            replacement = `analysis_to_replay=\"${analysisName}\")`;\n        }\n        else {\n            replacement = `, analysis_to_replay=\"${analysisName}\")`;\n        }\n        const newCode = currentCode.substring(0, lastIndex) + replacement + currentCode.substring(lastIndex + 1);\n        writeToCell(cell, newCode);\n        return true;\n    }\n    return false;\n}\nexport const notebookGetArgs = (analysisToReplayName) => {\n    const cellAndIndex = getMostLikelyMitosheetCallingCell(analysisToReplayName);\n    if (cellAndIndex) {\n        const [cell,] = cellAndIndex;\n        return getArgsFromMitosheetCallCode(getCellText(cell));\n    }\n    else {\n        return [];\n    }\n};\nexport const notebookWriteAnalysisToReplayToMitosheetCall = (analysisName, mitoAPI) => {\n    const cellAndIndex = getMostLikelyMitosheetCallingCell(analysisName);\n    if (cellAndIndex) {\n        const [cell,] = cellAndIndex;\n        const written = tryWriteAnalysisToReplayParameter(cell, analysisName);\n        if (written) {\n            return;\n        }\n    }\n    // Log if we are unable to write this param for any reason\n    void mitoAPI.log('write_analysis_to_replay_to_mitosheet_call_failed');\n};\nexport const notebookOverwriteAnalysisToReplayToMitosheetCall = (oldAnalysisName, newAnalysisName, mitoAPI) => {\n    const mitosheetCallCellAndIndex = getCellCallingMitoshetWithAnalysis(oldAnalysisName);\n    if (mitosheetCallCellAndIndex === undefined) {\n        return;\n    }\n    const [mitosheetCallCell,] = mitosheetCallCellAndIndex;\n    const overwritten = tryOverwriteAnalysisToReplayParameter(mitosheetCallCell, oldAnalysisName, newAnalysisName);\n    if (!overwritten) {\n        void mitoAPI.log('overwrite_analysis_to_replay_to_mitosheet_call_failed');\n    }\n};\nexport const notebookWriteGeneratedCodeToCell = (analysisName, codeLines, telemetryEnabled, publicInterfaceVersion, oldCode, triggerUserEditedCodeDialog, overwriteIfUserEditedCode) => {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;\n    const code = getCodeString(analysisName, codeLines, telemetryEnabled, publicInterfaceVersion);\n    // Find the cell that made the mitosheet.sheet call, and if it does not exist, give\n    // up immediately\n    const mitosheetCallCellAndIndex = getCellCallingMitoshetWithAnalysis(analysisName);\n    if (mitosheetCallCellAndIndex === undefined) {\n        return;\n    }\n    const [, mitosheetCallIndex] = mitosheetCallCellAndIndex;\n    const cells = (_b = (_a = window.Jupyter) === null || _a === void 0 ? void 0 : _a.notebook) === null || _b === void 0 ? void 0 : _b.get_cells();\n    if (cells === undefined) {\n        return;\n    }\n    const activeCellIndex = ((_d = (_c = window.Jupyter) === null || _c === void 0 ? void 0 : _c.notebook) === null || _d === void 0 ? void 0 : _d.get_anchor_index()) || 0;\n    const codeCell = getCellAtIndex(mitosheetCallIndex + 1);\n    const codeCellText = getCellText(codeCell);\n    // Prevent overwriting the cell if the user has changed the code\n    if (overwriteIfUserEditedCode === undefined && !isEmptyCell(codeCell) && hasCodeCellBeenEditedByUser(oldCode, codeCellText)) {\n        triggerUserEditedCodeDialog(oldCode, codeCellText.split('\\n'));\n        return;\n        // Only write to the cell if either of the following are true:\n        // 1. The user has authorized overwriting the cell\n        // 2. The cell hasn't been edited by the user\n        // AND the cell exists. If the cell doesn't exist we can't write to it!\n    }\n    else if (codeCell !== undefined && (overwriteIfUserEditedCode || !hasCodeCellBeenEditedByUser(oldCode, codeCellText))) {\n        writeToCell(codeCell, code);\n    }\n    else {\n        // If we cannot write to the cell below, we have to go back a new cell below, \n        // which can eb a bit of an involve process\n        if (mitosheetCallIndex !== activeCellIndex) {\n            // We have to move our selection back up to the cell that we \n            // make the mitosheet call to \n            if (mitosheetCallIndex < activeCellIndex) {\n                for (let i = 0; i < (activeCellIndex - mitosheetCallIndex); i++) {\n                    (_f = (_e = window.Jupyter) === null || _e === void 0 ? void 0 : _e.notebook) === null || _f === void 0 ? void 0 : _f.select_prev();\n                }\n            }\n            else if (mitosheetCallIndex > activeCellIndex) {\n                for (let i = 0; i < (mitosheetCallIndex - activeCellIndex); i++) {\n                    (_h = (_g = window.Jupyter) === null || _g === void 0 ? void 0 : _g.notebook) === null || _h === void 0 ? void 0 : _h.select_next();\n                }\n            }\n        }\n        // And then write to this new cell below, which is not the active cell but we\n        // should make it the actice cell\n        (_k = (_j = window.Jupyter) === null || _j === void 0 ? void 0 : _j.notebook) === null || _k === void 0 ? void 0 : _k.insert_cell_below();\n        (_m = (_l = window.Jupyter) === null || _l === void 0 ? void 0 : _l.notebook) === null || _m === void 0 ? void 0 : _m.select_next();\n        const activeCell = (_p = (_o = window.Jupyter) === null || _o === void 0 ? void 0 : _o.notebook) === null || _p === void 0 ? void 0 : _p.get_cell((_r = (_q = window.Jupyter) === null || _q === void 0 ? void 0 : _q.notebook) === null || _r === void 0 ? void 0 : _r.get_anchor_index());\n        writeToCell(activeCell, code);\n    }\n};\nexport const notebookWriteCodeSnippetCell = (analysisName, code) => {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;\n    // Find the cell that made the mitosheet.sheet call, and if it does not exist, give\n    // up immediately\n    const mitosheetCallCellAndIndex = getCellCallingMitoshetWithAnalysis(analysisName);\n    if (mitosheetCallCellAndIndex === undefined) {\n        return;\n    }\n    const [, mitosheetCallIndex] = mitosheetCallCellAndIndex;\n    const cells = (_b = (_a = window.Jupyter) === null || _a === void 0 ? void 0 : _a.notebook) === null || _b === void 0 ? void 0 : _b.get_cells();\n    if (cells === undefined) {\n        return;\n    }\n    const codeCell = getCellAtIndex(mitosheetCallIndex + 1);\n    if (isEmptyCell(codeCell)) {\n        writeToCell(codeCell, code);\n    }\n    else {\n        // Otherwise, we assume we have the mitosheet selected, so we select the next one, and then \n        // insert below so we have new cell below the generated code\n        (_d = (_c = window.Jupyter) === null || _c === void 0 ? void 0 : _c.notebook) === null || _d === void 0 ? void 0 : _d.select_next();\n        (_f = (_e = window.Jupyter) === null || _e === void 0 ? void 0 : _e.notebook) === null || _f === void 0 ? void 0 : _f.insert_cell_below();\n        (_h = (_g = window.Jupyter) === null || _g === void 0 ? void 0 : _g.notebook) === null || _h === void 0 ? void 0 : _h.select_next();\n        const activeCell = (_k = (_j = window.Jupyter) === null || _j === void 0 ? void 0 : _j.notebook) === null || _k === void 0 ? void 0 : _k.get_cell((_m = (_l = window.Jupyter) === null || _l === void 0 ? void 0 : _l.notebook) === null || _m === void 0 ? void 0 : _m.get_anchor_index());\n        writeToCell(activeCell, code);\n    }\n};\nexport const writeEmptyMitosheetCell = () => {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\n    // Create a new cell below the active code cell\n    (_b = (_a = window.Jupyter) === null || _a === void 0 ? void 0 : _a.notebook) === null || _b === void 0 ? void 0 : _b.insert_cell_below();\n    (_d = (_c = window.Jupyter) === null || _c === void 0 ? void 0 : _c.notebook) === null || _d === void 0 ? void 0 : _d.select_next();\n    const activeCell = (_f = (_e = window.Jupyter) === null || _e === void 0 ? void 0 : _e.notebook) === null || _f === void 0 ? void 0 : _f.get_cell((_h = (_g = window.Jupyter) === null || _g === void 0 ? void 0 : _g.notebook) === null || _h === void 0 ? void 0 : _h.get_anchor_index());\n    // Add mitosheet.sheet call to new code cell\n    if (isEmptyCell(activeCell)) {\n        writeToCell(activeCell, 'import mitosheet\\nmitosheet.sheet()');\n        (_k = (_j = window.Jupyter) === null || _j === void 0 ? void 0 : _j.notebook) === null || _k === void 0 ? void 0 : _k.execute_cell_and_insert_below();\n    }\n};\n//# sourceMappingURL=extensionUtils.js.map","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\tloaded: false,\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.hmd = (module) => {\n\tmodule = Object.create(module);\n\tif (!module.children) module.children = [];\n\tObject.defineProperty(module, 'exports', {\n\t\tenumerable: true,\n\t\tset: () => {\n\t\t\tthrow new Error('ES Modules may not assign module.exports or exports.*, Use ESM export syntax, instead: ' + module.id);\n\t\t}\n\t});\n\treturn module;\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(\"./lib/jupyter/notebook/extension.js\");\n",""],"names":[],"sourceRoot":""}