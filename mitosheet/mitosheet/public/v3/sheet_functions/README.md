# Guide to Writing Sheet Functions

## How to Write Sheet
For formulas, we're recommending that test your code *before* implementing. For formulas especially, testing is going to be very direct: you give the formula an input, and expect an output. It's also very quick to run tests! As such, it really speeds up the implementation process by having test cases ready to go before and as you implement. This will help with ironing out what the different input options are, and as you're implementing it'll be a really straightforward way to see if your function is working as expected. Here's a recommended order for writing a new formula function:
    * Write the tests for the formula (see below for guidelines)
    * Write the formula function. This could include stopping to write more test cases!
    * Write the docstring and run the script to generate the frontend code (see #1 in context section below)
    * Test it in the actual Mitosheet

## Context on Formulas
From frontend to backend (in order), a formula will have the following order of operations:
1. The user edits a cell to include a formula. They'll see some information in a dropdown below the cell editor that's autogenerated from a docstring in the python function for that formula. If you edit that docstring or create a new function, you'll want to run `mitosheet/docs/make_function_docs.py update_frontend` to update the information displayed in that dropdown. 
2. Validation is run through the backend in `parser.py` to check for things like the validity of the columns used as input and whether the formula exists.
3. If it passes validation, the parser takes the raw string that the user created, and converts it to python code. This is a good step for debugging! You can see what the parser is generating by looking at the code chunk, and you can see exactly what your python function is going to be getting as input.
4. **Arguments to the formula function:** When you write a formula in the mitosheet, users can use four things as arguments: a cell range (i.e. E10:G12), a column, a cell, or a constant value. As such, when you write a formula's arguments, you'll need to handle both the case that an argument is a series, and the case that the argument is a constant. There are helper functions to make this more manageable! Namely, the `get_series_from_primitive_or_series` function will make it easy to make sure you're exclusively dealing with series to simplify the code. 
    * If you're expecting specific types for your arguments, you can add a typecast above the function that looks like this:
    ```
    @cast_values_in_all_args_to_type('bool')
    ```
5. Error handling: You can add errors for invalid arguments by using the `MitoError` class:
```
raise MitoError(
    'invalid_args_error',
    '<Formula Name>',
    f"<Formula Name> requires all even indexed arguments to be boolean.",
    error_modal=False
)
```
6. **Return values for formula functions:** As is explained above ^^, a formula can be applied to an entire column or to a single cell, so you're going to want to return the same type as you're receiving as input. When you get a series, return a series with the same index. When you get a constant, you're returning a constant. 

## Testing 
* Test the valid cases *and* the invalid cases. If you're using `MitoError`, test for the content of the error!
* Add tests for different variations of series and constants. If you use a constant as input, are you getting a constant as output? Is that true of series? 
* Add tests for different data types - especially if you're not casting the types for your function (see #4 above). 
* Add tests for unusual amounts of arguments. Do you have a limited number of arguments? Should it throw an error if so? 
